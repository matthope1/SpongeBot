import os
import telebot
import time
import requests
import ast
import random
from replit import db
import asyncio
from functools import wraps
from threading import Thread
from pytube import YouTube
import json
from messages import *


from web3 import Web3
import time, json


from datetime import datetime


# how to restrict access https://stackoverflow.com/questions/35368557/how-to-limit-access-to-a-telegram-bot


# youtube player bot example, https://www.youtube.com/watch?v=ml-5tXRmmFk&ab_channel=RoboticNation

# I think we'll want people or admin to be able to play songs with song names or url's


# db tut https://github.com/replit/replit-py/blob/fc47b96202667ca8a04827285a19e94912bdca29/docs/db_tutorial.rst

# https://stackoverflow.com/questions/67177501/horizontally-scale-discord-py


# How to interact with bsc
# https://paohuee.medium.com/interact-binance-smart-chain-using-python-4f8d745fe7b7



'''
https://t.me/overdose_gems_group

http://t.me/InfinityGainzz (http://t.me/InfinityGainzz)

https://t.me/DeFiRaccoons

https://t.me/cryptodakurobinhooders

https://t.me/gamblebsc

https://t.me/LBank_en

https://t.me/spongegems

https://t.me/Crypto_Talkzs

https://t.me/pressed4coinsnew

https://t.me/moonhunters

https://t.me/SSBtalk

https://t.me/DeFiApeTalk

https://t.me/Pharrells_Whales

https://t.me/BitSquad
 (https://t.me/BitSquad)
https://t.me/AMA_Central

https://t.me/ProdsLounge
 (https://t.me/ProdsLounge)
https://t.me/icospeaks

https://t.me/ROGERthegreat

https://t.me/satoshistreetbets
 (https://t.me/satoshistreetbets)
https://t.me/de_fi

https://t.me/GKsGems

https://t.me/rektsfamily

https://t.me/cryptoscavengergroup

'''


'''
# personal useage 
send the bot to other rooms to do work
play music, have it conduct a shill raid

shill raid/ leader
it would use a bunch of saved chat urls
it picks a random url, then itll say 3 2 1, and post one of these random urls

the users in that group will go to that group and post their shill text

leader text example: 

OK GUYS GET READY TO SHILL
 5 sec 
/ shill or soft shill
5 sec

so make it so main admin can add users to admin list, where they can have access to the bot for a user defined amount of time

if someone who is not admin makes a request to the bot and they are not admin,
send message saying "you need to be an admin to use this bot, please talk to Sponge "

add /help

/raid for automated shill raid

/music-playlist 1 : house
/music-playlist 2 : rap  
/music-playlist 3 : default 

/music command connects to music live stream


a bot that is automated to send messages to public groups
sends messages to a public group on a time interval
add the ability to change the shill message and add pictures to messages?


# HOW TO AUTOMATE PAYMENTS

We'll need a smart contract and a web3 interface

The smart contract would handle the payments to sponge

function buyBotAccess(telegram username or 1 time passcode generated by the bot)
simply sends the bnb to sponge end emit event to bot backend
https://web3py.readthedocs.io/en/stable/contracts.html?highlight=events#events 

when this event is captured by the bot,
the user will gain access to the bot for the amount of time that they paid for
Then the bot can also DM sponge after this and let them know which user 
just paid for bot access


How to make sure this scales?





WHOOOOH CONTRACT:

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.10;


contract SpongeBotPayment {
    string public greet = "Hello World!";

    event Deposit(address indexed sender, uint amount, uint balance);
    event UserPaid(string username);

    function pay(string memory _username) public payable {
        emit UserPaid(_username);
    }

    // Function to receive Ether. msg.data must be empty
    receive() external payable {
        emit Deposit(msg.sender, msg.value, address(this).balance);
    }

    // Fallback function is called when msg.data is not empty
    fallback() external payable {}

    function getBalance() public view returns (uint) {
        return address(this).balance;
    }
}
'''

# BSC SC connection setup
  
# MAINNET
# bsc = "https://bsc-dataseed.binance.org/"

bscTest = "https://data-seed-prebsc-1-s1.binance.org:8545/"

web3 = Web3(Web3.HTTPProvider(bscTest))
print(web3.isConnected())

contract_abi =  json.loads(""" 
[
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "_secondaryOwner",
				"type": "address"
			}
		],
		"stateMutability": "nonpayable",
		"type": "constructor"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"internalType": "address",
				"name": "sender",
				"type": "address"
			},
			{
				"indexed": false,
				"internalType": "uint256",
				"name": "amount",
				"type": "uint256"
			},
			{
				"indexed": false,
				"internalType": "uint256",
				"name": "balance",
				"type": "uint256"
			}
		],
		"name": "Deposit",
		"type": "event"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": false,
				"internalType": "string",
				"name": "username",
				"type": "string"
			},
			{
				"indexed": false,
				"internalType": "uint256",
				"name": "value",
				"type": "uint256"
			}
		],
		"name": "UserPaid",
		"type": "event"
	},
	{
		"inputs": [],
		"name": "getBalance",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "onlyPrimaryOwner",
		"outputs": [],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "string",
				"name": "_username",
				"type": "string"
			}
		],
		"name": "pay",
		"outputs": [],
		"stateMutability": "payable",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "primaryOwner",
		"outputs": [
			{
				"internalType": "address payable",
				"name": "",
				"type": "address"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "secondaryOwner",
		"outputs": [
			{
				"internalType": "address payable",
				"name": "",
				"type": "address"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "_amount",
				"type": "uint256"
			}
		],
		"name": "withdraw",
		"outputs": [],
		"stateMutability": "payable",
		"type": "function"
	}
]
""")


contract_address = '0x909b6D4398a8206eCaD60ed6535eeDD508C45215'
contract = web3.eth.contract(address=contract_address, abi=contract_abi)


# SC event loop and handler
def handle_event(event):
  eventDict = json.loads(web3.toJSON(event))
  eventName = eventDict['event']

  if eventName == "UserPaid":
    print("user paid event")

    username = eventDict['args']['username']
    value = eventDict['args']['value']

    print("username", username)
    print("value",value)

    # add user to admin list based on the amount of value included on that
    # transaction

    # heres how the pricing model works
    # .15 bnb / hour
    # one .3 discount for 6 or more hours
    # 7

  return json.loads(web3.toJSON(event)) 

def log_loop(event_filter, poll_interval):
  while True:
    for contractEvent in event_filter.get_new_entries():
      handle_event(contractEvent)
    time.sleep(poll_interval)


# SC testing 

address = "0x772E8A12A8374A4d070538Ea920A4339Bb0959e7" 
balance = web3.eth.get_balance(address)
print(balance)
 
result = web3.fromWei(balance,"ether")
print(result)

# Sponge Bot
API_KEY = os.getenv('API_KEY')
bot = telebot.TeleBot(API_KEY)


chat_id = 'Sponge_bot_testing'

print("Sponge bot running...")


def check_game_master(func):
  '''Decorator that reports the execution time.'''

  def wrap(*args, **kwargs):
    message = args[0]
    
    res = is_game_master(message.from_user.id)
    if res :
      result = func(*args, **kwargs)
      return result
    else:
      bot.send_message(message.chat.id, f"You are not the game master.")
      return

  return wrap

def check_admin(func):
  '''Decorator that reports the execution time.'''

  def wrap(*args, **kwargs):
    message = args[0]
    id = message.from_user.id

    user_is_admin, err_msg = is_admin(message.from_user.username)

    # if message is from sponge
    if id == 1054822819:
      print("command is from sponge")
      user_is_admin = True 

    print("user_is_admin",user_is_admin)

    if user_is_admin:
      result = func(*args, **kwargs)
      return result
    else:
      if err_msg:
        bot.send_message(message.chat.id, f"{err_msg}")
      else:   
        bot.send_message(message.chat.id, f"You are not an admin, please contact sponge to gain admin access")

  return wrap

def list_database():
  keys = db.keys()

  for key in keys:
    current_val = db[key]
    print(f"key {key} | value {current_val}")


def is_admin(username):
  # is admin needs to check how long since the user we are validating has been inside of the admin list
  # we need to be able to check if a certain amount of time has passed to revoke admin status

  found = False
  user_acc = ''

  # if any(d['username'] == username for d in db["adminList"]):
  # also check if time past is less than some alotted time 

  raw_admin_list = ast.literal_eval(db.get_raw("adminList"))

  for user in raw_admin_list:
    if user['username'] == username:
      user_acc = user
      found = True, 

  if found:
    # TODO: get this user from the database (add get user util function)
    # then for check_time_passed, pass in user_admin_time
    

    res = check_time_passed(user_acc['createdDate'], 3)
    # res = check_time_passed(user_acc['createdDate'], 0.001)
    if not res:
      # user is still admin
      # FIXME: why does this not continue on to the requested function call
      print("user is still an admin, continue on to requested fuction call")
      return True, 'noerr'
    else:
      raw_admin_list.remove(user_acc)
      print("raw admin list after removal", raw_admin_list)
      db['adminList'] = raw_admin_list
      print("user ran out of admin time")
      # TODO: add name of buy time command
      return False, 'Sorry! Your time as admin has ran out, please purchase more time with {PLACE BUY TIME CMD HERE}'

  else:
    print("not found")
    return False, 'You are not an admin'

def is_game_master(userId):
  print("is game master called", userId)

  if userId == db["gameMaster"]:
    return True
  else:
    return False

def db_init():
  # reset values for all keys in db
  db["chatNames"] = [] 
  db["chatLinks"] = []
  db["adminList"] = []

  print("database initialization complete")

def parse_chat_link(raw_link):
  parsed_link = raw_link.split('t.me/')
  chat_id = parsed_link[1]
  return chat_id

# checks if more time has passed than the hours argument
# returns boolean (true if more time as passed)
def check_time_passed(dateTimeStr, hours):
  dateTimeObj = datetime.strptime(dateTimeStr , '%d/%m/%y %H:%M:%S') 
  now = datetime.now()
  timeDiff = (now - dateTimeObj)
  timeDiffInSeconds =  timeDiff.total_seconds() 

  print("time diff in seconds", timeDiffInSeconds)

  # 3600 seconds in an hour
  if timeDiffInSeconds > hours * 3600:
    print(f"more than {hours} hours have passed")
    return True
  else:
    print(f"less than {hours} hours have passed")
    return False


# TODO: make it so that this function displays how much time is remaining on the users
# admin access
@bot.message_handler(commands=['time_left'])
@check_admin
def time_left(message):
  # get admin user object from database for user who sent message
  # calculate how much time is left before their admin priv expires
  # return/display time to user
  print('time left called')
  username = message.from_user.username

  raw_admin_list = ast.literal_eval(db.get_raw("adminList"))


  for user in raw_admin_list:
    print(f"{user['username']} == {username}")
    print(user['username'] == username)
    if user['username'] == username:
      print("user found")
      date_time_str = user['createdDate']
      print(f"date time str = {date_time_str}")
      # TODO: fix me
      date_time_obj = datetime.strptime(date_time_str, '%d/%m/%y %H:%M:%S')
      print("before")
      print(date_time_obj)
      print("after")
      print(f"time left for {username}: {date_time_obj} ")
      now = datetime.now()
      print(f"current time {now}")
      print(f"time diff = {now - date_time_obj}")
      bot.send_message(message.chat.id, f"Time left as admin: {date_time_obj}")
    else: 

      print("user not found")

      bot.send_message(message.chat.id, f"Looks like you ran out of time")

# internal function for adding user to admin list


# takes in username with no @ symbol
def admin_exists(username):
  return any(d['username'] == username for d in db["adminList"])

def add_user_admin(username, timeLimit):
  # TODO: add this user to admin list 

  if '@' not in username:
    # warning: this will fail if the function is called with a username like this: 
    # test@me
    print("incorrect username format")
    return 

  username = username.split('@')[1].strip()
  createdDate = datetime.now().strftime('%d/%m/%y %H:%M:%S')

  new_admin = {
    "username": username,
    "createdData": createdDate
  }

  try: 
    if not admin_exists(username):
      # append copy of dict to create new ref
      db["adminList"].append(new_admin.copy())

      if admin_exists(username): 
        print("user sucessfully added to the admin list")

    else:
      print("user is already an admin")
  except:
    print("add admin failure")


@bot.message_handler(commands=['add_admin'])
@check_game_master
def add_user_admin_handler(message):
  # handler for adding admin level user in database


  # check if username is given in correct format
  if '@' not in message.text:
    bot.send_message(message.chat.id, "incorrect username format")
    return

  username = message.text.split('@')[1].strip()
  createdDate = datetime.now().strftime('%d/%m/%y %H:%M:%S')

  # TODO: add admin_time_limit
  # TODO: in check user admin function, check against this admin_time limit key
  # admin_time_limit should be in hours (float)

  new_admin = {
    "username" : username,
    "createdDate": createdDate 
  }

  try:
    # if not any(d['username'] == username for d in db["adminList"]):
    if not admin_exists(username):
      # append copy of dict to create new ref
      db["adminList"].append(new_admin.copy())
  
      if admin_exists(username):
        bot.send_message(message.chat.id, f"{username} was sucessfully added to your admin list")
    else:
      bot.send_message(message.chat.id, f"This user is already an admin")
  
  except:
    bot.send_message(message.chat.id, f"There was an error while trying to add {username} to admin list")

@bot.message_handler(commands=['dbInit'])
@check_game_master
def db_init_handler(message):
  db_init()

@bot.message_handler(commands=['Greet'])
@check_game_master
def greet(message):
  
  user = message.from_user 
  print("user", user.id)
  list_database()

  bot.reply_to(message, "Hey! Hows it going?")

@bot.message_handler(commands=['view_admins'])
@check_game_master
def view_admins(message):

  raw_admin_list = ast.literal_eval(db.get_raw("adminList"))

  print("admins: ", raw_admin_list)
  bot.reply_to(message, f"admins: {raw_admin_list}")

  for user in raw_admin_list:
    print("username", user['username'])
    print("date created", user['createdDate'])

"""

TODO: 

Create a message handler that can allow the addition of new messages to be sent?

"""

@bot.message_handler(commands=['view_groups'])
def view_groups(message):
  print("view groups called")

  # get chat list from db
  # Loop through groups list and append each list onto send string
  # send back to the chat the send string

  try: 
    chat_links = db["chatLinks"]
  
    return_message = ""
  
    for chat_link in chat_links:
      return_message += chat_link
      return_message += " "
    
    bot.send_message(message.chat.id, f"Groups: {return_message}")
  
  except: 
    bot.send_message(message.chat.id, "There was an error while trying to view all saved groups. Please try again or contact my creator")


@bot.message_handler(commands=['remove_group'])
def remove_group(message):
  print("remove group called")

  try:
    if(message.text):
      print("message", message.text)
      chat_link = message.text.split('remove_group')[1]
      
      print("chat_link", chat_link)

      if chat_link in db["chatLinks"]:
        db["chatLinks"].remove(chat_link)
        if chat_link not in db["chatLinks"]:
          bot.send_message(message.chat.id, f"Group {chat_link} sucessfully removed from your saved groups")
      else:
        bot.send_message(message.chat.id, f"Group {chat_link} is not saved in your groups list")
  
  except:
    bot.send_message(message.chat.id, f"There was an error while trying to remove group. Please try again or contact my creator")

@bot.message_handler(commands=['add_group'])
@check_admin
def add_group(message):
  print("add group called")

  try :
    if(message.text):
      print("message.text: ", message.text)
  
      chat_link = message.text.split('add_group')[1]
  
      print("chatLink", chat_link)
  
      if chat_link not in db["chatLinks"]:
        db["chatLinks"].append(chat_link)
  
        if chat_link in db["chatLinks"]:
          bot.send_message(message.chat.id, f"Group {chat_link} was sucessfully added to your group list")
      else:
        bot.send_message(message.chat.id, f"Group {chat_link} already added to your group list")

  except:
    bot.send_message(message.chat.id, "There was an error while trying to add to your group list. Please try again or contact my creator")


# shill raid/ leader
# it would use a bunch of saved chat urls
# it picks a random url, then itll say 3 2 1, and post one of these random urls

# the users in that group will go to that group and post their shill text

# leader text example: 

# OK GUYS GET READY TO SHILL
#  5 sec 
# / shill or soft shill
# 5 sec


# TODO: create message handler to display all commands for this bot

@bot.message_handler(commands=['commands', 'help'])
def display_commands(message):

  print("display commands called")

  commands = (
    f'/shill, /soft_shill \n'
    f'/view_admins \n'
    f'/message_all_groups \n'
    f'/message_chat \n'
    f'/time_left \n'
    f'/view_groups \n'
    f'/add_group \n'
    f'/remove_group \n'
    # f'/ \n'
  )
  
  bot.send_message(message.chat.id, f"Spongebot has the following commands: \n {commands}")


chaturls = ['https://t.me/testChannelspongey', 'https://t.me/Sponge_bot_testing', 'https://t.me/testChannelSpongey2']

# TODO: create the auto shill bot
@bot.message_handler(commands=['shill', 'soft_shill'])
@check_admin
def shill(message):
  print("")
  print("")
  print("")
  print("shill called", message)
  print("")
  print("")
  print("")

  # get random number
  n = random.randint(0,len(chaturls) - 1)

  print("n", n)

  # use number to get random entry from the chat urls list
  randomUrl = chaturls[n]

  print("randomUrl", randomUrl)

  # send chat url to the group 

  if message.text == '/shill':
    print("shill called")

    bot.send_message(message.chat.id, "EVERYONE COPY THE HARDSHILL TEXT FROM ROSE!")
    bot.send_message(message.chat.id, "/hardshill")
    time.sleep(2)

    bot.send_message(message.chat.id, "OK GUYS GET READY TO SHILL")
    time.sleep(5)
    bot.send_message(message.chat.id, f"POSTING THE RAID LINK IN 3...")
    time.sleep(1)
    bot.send_message(message.chat.id, f"2...")
    time.sleep(1)
    bot.send_message(message.chat.id, f"1...")
    time.sleep(1)

    bot.send_message(message.chat.id, f"GO! {randomUrl}")

    # TODO: when the shilling starts, the bot should continually go through a list of groups
    # and post a new group every 2 - 5 mins
    # the admins should be able to skip a group and go onto the next posting
    # in the case that the chat is locked and users cant raid the chat

    # TODO: add the bi

  elif message.text == '/soft_shill':
    print("soft shill called")
    bot.send_message(message.chat.id, "OK GUYS GET READY TO SOFT SHILL")
    bot.send_message(message.chat.id, "Soft shilling is: talking about the project in a casual manor that may not come off as shilling to people who arenâ€™t aware of what shilling is")
    
    # TODO: Post the groups
    # alright guys 

# TODO: test me
@bot.message_handler(commands=['message_all_groups'])
def message_all_groups(message):
  print("message all groups called")

  try:
    if(message.text):

      # Loop through all chats
      # for each chat, parse the link to get the chat id
      # make a call to the telegram api to send message to the chat

      chat_links = db["chatLinks"]

      message_to_send = "this is a test message"

      for chat_link in chat_links:
        chat_id = parse_chat_link(chat_link)
        print("chatid: ", chat_id)
        telegram_api_url = f"https://api.telegram.org/bot{API_KEY}/sendMessage?chat_id=@{chat_id}&text={message_to_send}"
        # TODO: add error handling here
        # if message request to the api fails, send message back to user saying that there was an issue sending message to this group
        try: 
          tel_resp = requests.get(telegram_api_url)
          if not tel_resp: 
            bot.send_message(message.chat.id, f"There was an issue sending a message to {chat_link}")

        except: 
          # TODO: test what happens when the message fails
          # what happens when that group doesn't exist
          bot.send_message(message.chat.id, f"There was an issue sending a message to {chat_link}")
    
  except:
    bot.send_message(message.chat.id, "There was an error while trying to send a message to all groups. Please try again or contact my creator")


@bot.message_handler(commands=['message_chat'])
def message_chat(message):

  telegram_api_url = f"https://api.telegram.org/bot{API_KEY}/sendMessage?chat_id=@{chat_id}&text={packages_string}"

  tel_resp = requests.get(telegram_api_url)

  print()
  print()
  print("message:", message)
  print("chat id: ", message.chat.id)
  print()
  print()

  # bot.reply_to(chat_id, packages_string)
  # bot.send_message(chat_id, packages_string)

@bot.message_handler(commands=['hello'])
def hello(message):
  bot.send_message(message.chat.id, "Hello!")

@bot.message_handler(commands=['packages'])
def packages(message):
  bot.send_message(message.chat.id, packages_string)


# TODO: 

def yt_search(song):
  videosSearch = VideosSearch(song, limit=1)
  result = videosSearch.result()
  if not result:
      return False
  else:
      video_id = result["result"][0]["id"]
      url = f"https://youtu.be/{video_id}"
      return url

@bot.message_handler(commands=['Song'])
async def song(client, message):
    print("song called")
    chat_id = message.chat.id
    user_id = message.from_user["id"]
    # add_chat_to_db(str(chat_id))
    args = get_arg(message) + " " + "song"
    if args.startswith(" "):
        await message.reply("Enter a song name. Check /help")
        return ""
    status = await message.reply("ğŸš€ ğŸ” ğŸ” ğ’ğğšğ«ğœğ¡ğ¢ğ§ğ  ğ­ğ¡ğ ğ¬ğ¨ğ§ğ ... ğŸ¶ ğğ¥ğğšğ¬ğ ğ–ğšğ¢ğ­ â³ï¸ ğ…ğ¨ğ« ğ…ğğ° ğ’ğğœğ¨ğ§ğğ¬ [ğŸš€](https://telegra.ph/file/67f41ae52a85dfc0551ae.mp4)")
    video_link = yt_search(args)
    if not video_link:
        await status.edit("âœ–ï¸ ğ…ğ¨ğ®ğ§ğ ğğ¨ğ­ğ¡ğ¢ğ§ğ . ğ’ğ¨ğ«ğ«ğ².\n\nğ“ğ«ğ² ğ€ğ§ğ¨ğ­ğ¡ğğ« ğŠğğ²ğ°ğ¨ğ«ğ¤ ğğ« ğŒğšğ²ğ›ğ ğ’ğ©ğğ¥ğ¥ ğˆğ­ ğğ«ğ¨ğ©ğğ«ğ¥ğ².\n\nEg.`/song Faded`")
        return ""
    yt = YouTube(video_link)
    audio = yt.streams.filter(only_audio=True).first()
    try:
        download = audio.download(filename=f"{str(user_id)}")
    except Exception as ex:
        await status.edit("Failed to download song ğŸ˜¶")
        LOGGER.error(ex)
        return ""
    rename = os.rename(download, f"{str(user_id)}.mp3")
    await app.send_chat_action(message.chat.id, "upload_audio")
    await app.send_audio(
        chat_id=message.chat.id,
        audio=f"{str(user_id)}.mp3",
        duration=int(yt.length),
        title=str(yt.title),
        performer=str(yt.author),
        reply_to_message_id=message.message_id,
    )
    await status.delete()
    os.remove(f"{str(user_id)}.mp3")

# bot.polling()
def telegram_polling():
    print("telegram polling called")

    try:

      event_filter = contract.events.UserPaid.createFilter(fromBlock='latest')
  
      worker = Thread(target=log_loop, args=(event_filter, 2), daemon=True)
      worker.start()
  
      bot.polling(none_stop=True, timeout=60) #constantly get messages from Telegram

    except:

        # traceback_error_string=traceback.format_exc()

        # with open("Error.Log", "a") as myfile:
        #     myfile.write("\r\n\r\n" + time.strftime("%c")+"\r\n<<ERROR polling>>\r\n"+ traceback_error_string + "\r\n<<ERROR polling>>")
            
        bot.stop_polling()
        time.sleep(10)
        telegram_polling()

if __name__ == '__main__':    
    telegram_polling()